# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LwfOhTbkKqN73GGP-gk5MTRc_kcNnr98

Name : Guizhi Xu

CWID : 20008770

email: gxu14@stevens.edu
"""

# Import all the required libraries
import numpy as np
import pandas as pd
import operator

"""Read the Dataset using read_csv function from Pandas"""

## Read the dataset from the two files into ratings_data, movies_data and user_data
ratings_data = pd.read_table("ratings.dat", sep = "::", header = None, encoding = 'ISO-8859-1')
movies_data = pd.read_table("movies.dat", sep = "::", header = None, encoding = 'ISO-8859-1')
user_data = pd.read_table("users.dat", sep = "::", header = None, encoding = 'ISO-8859-1')

"""Use Numpy to create a ratings data matrix. Print the shape of the matrix"""

ratings_data = ratings_data.rename(columns={0: "user_id" , 1: "movie_id" , 2: "rating" , 3: "serialnumber" })
ratings_data.head()

movies_data = movies_data.rename(columns = {0: "movie_id" , 1: "title" , 2: "genre"})
movies_data.head()

user_data = user_data.rename(columns={0: "user_id" , 1: "gender" , 2: "age" , 3: "characteristiccode" , 4: "address"})
user_data.head()

ratings_mat = np.ndarray(shape=(np.max(ratings_data.movie_id.values), np.max(ratings_data.user_id.values)),dtype=np.uint8)
ratings_mat[ratings_data.movie_id.values - 1, ratings_data.user_id.values - 1] = ratings_data.rating.values
ratings_mat

"""Normalize the Ratings Data matrix"""

normalised_matrix = ratings_mat - np.asarray([(np.mean(ratings_mat, 1))]).T
normalised_matrix

"""Use the SVD function from numpy to perform SVD on the normalised ratings data matrix. Print the shapes of U, S, V matrices."""

U,S,V = np.linalg.svd(normalised_matrix.T / np.sqrt(ratings_mat.shape[0] - 1))
U

"""Explain the differences between Cosine similarity and Euclidean distance. What are they and what do they do? Which one is better for movie recommendation and why?

When a pair of text similarities has a large difference in length but similar content, the Euclidean distance of them in the feature space is usually large if word frequency or word vector is used as the feature, while the angle between them may be small if cosine similarity is used, and thus the similarity is high. In addition, in the fields of text, image, video, etc., where the feature dimension of the object under study is often high, the cosine similarity still maintains the property of "1 when identical, 0 when orthogonal, and -1 when opposite" in the high-dimensional case, while the value of Euclidean distance is affected by the dimensionality, and the range is not fixed, and the meaning is also vague.

Euclidean distance between two points in Euclidean space is the length of a line segment between the two points. It can be calculated from the Cartesian coordinates of the points using the Pythagorean theorem. 

Cosine similarity between two vectors corresponds to their dot product divided by the product of their magnitudes.

Cosine similarity is better for movie recommendation. When two users have the same rating trend, but the rating values are very different, the cosine similarity tends to give a more optimal solution, but the solution given by the Euclidean distance is obviously not as reasonable as the cosine value.
"""

def print_top5moivesrecommendations(movie_data, movie_id, top_indexes):
    print('top 5 movies that match a given a movie title are(total would be 6 if the given tilte was included):')
    for id in top_indexes + 1:
        print(movie_data[movie_data.movie_id == id].title.values[0])      
sliced = V[:,:]

"""Based on cosine similarity and the matrix decomposition from SVD, sort the movies which are most similar and return the top 5 movies that match a given a movie title"""

# movie_id = int(input("Give a movie title"))
# for example, I choose No.1355(Nightwatch) to run the process
movie_id = 1355
print()
indexes = cosine_similarity(sliced, movie_id, 1+5)
print_top5moivesrecommendations(movies_data, movie_id, indexes)